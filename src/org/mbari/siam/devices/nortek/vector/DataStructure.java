/*
Copyright 2013 MBARI, all rights reserved. 
For license and copyright details, see COPYRIGHT.TXT in the SIAM project
home directory.
*/
package org.mbari.siam.devices.nortek.vector;

import org.mbari.siam.utils.StopWatch;
import org.mbari.siam.utils.StreamUtils;
import org.apache.log4j.Logger;
import org.mbari.siam.distributed.TimeoutException;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;



/** Data structure represents data generated by the Aquadopp, and includes
 method to read the data. */
public class DataStructure implements Serializable {

    private static final Logger log = Logger.getLogger(DataStructure.class);
    private static final long serialVersionUID=1L;

    // "Raw" bytes of structure
    byte[] _dataBytes = new byte[2048];

    public DataStructure() {
    }

    public static boolean isInstrumentConfiguration(byte[] dataBytes) {
        return id(dataBytes) == Aquadopp.INSTRUMENT_CONFIGURATION;
    }

    public static boolean isHRProfilerData(byte[] dataBytes) {
        return id(dataBytes) == Aquadopp.HR_PROFILER_DATA;
    }

    public static boolean isProfilerVelocityData(byte[] dataBytes) {
        return id(dataBytes) == Aquadopp.PROFILER_VELOCITY_DATA;
    }

    public static boolean isVectorVelocityData(byte[] dataBytes) {
        return id(dataBytes) == Vector.VECTOR_VELOCITY_DATA;
    }

    /** Return id of this structure. */
    public byte id() {
        return _dataBytes[1];
    }

    /** Return id of this structure. */
    public static byte id(byte[] dataBytes) {
        return dataBytes[1];
    }

    /** Return total words in this structure. */
    public short totalWords() {
	/* Vector Velocity message is special case - no word counter */
	if (id() == Vector.VECTOR_VELOCITY_DATA)
	    return(12);

        short hibyte = (short )_dataBytes[3];
        return (short) ((_dataBytes[2] & 0xff) | (hibyte << 8));
    }


    /** Return total words in this structure. */
    public static short totalWords(byte[] dataBytes) {

	/* Vector Velocity message is special case - no word counter */
	if (id(dataBytes) == Vector.VECTOR_VELOCITY_DATA)
	    return(12);

        short hibyte = (short )dataBytes[3];
        return (short) ((dataBytes[2] & 0xff) | (hibyte << 8));
    }


    /** Set contents of raw data byte array. */
    public void setBytes(byte[] dataBytes) {
        if (_dataBytes.length < dataBytes.length) {
            _dataBytes = new byte[dataBytes.length];
        }

        System.arraycopy(dataBytes, 0, _dataBytes, 0, dataBytes.length);
    }

    /** String representation */
    public String toString() {
        return "id=0x" + Integer.toHexString(id())  + "; totalWords=" + totalWords();
    }


    /** Read raw bytes of a single data structure from the input stream. */
    public static int read(InputStream input, byte[] dataBytes, long startTimeout) throws TimeoutException, IOException, Exception {

        int nRead = 0;
        long start = 0;
        int c = 0;
        boolean started = false;
        int nAvail = 0;

        // Look for sync byte from instrument
        while (true) {

            if (!started) {
                start = System.currentTimeMillis();
                log.debug("read(): start sync timeout timer");
                started = true;
            }

            if ((System.currentTimeMillis()  - start) > startTimeout) {
                log.error("Timed out while searching for sync for " +
                        startTimeout + " msec");
                throw new TimeoutException("Timed out in read()");
            }

            if ((nAvail = input.available()) <= 0) {
                StopWatch.delay(50);
                continue;
            }

            // log.debug("read() - read a byte");
            if ((c = input.read()) == -1) {
                throw new Exception("read() - eof while looking for sync");
            }

            // log.debug("read(): got 0x" + Integer.toHexString(c));

            // Did we get sync byte?
            if (c == Aquadopp.SYNC_BYTE) {
                log.debug("read(): Got sync");
                dataBytes[0] = (byte) 165;

                // Read data type ID byte
                if ((dataBytes[1] = (byte) input.read()) == -1) {
                    throw new Exception("read() - eof while reading record type");
                }

                log.debug("read(): Record is type 0x" + Integer.toHexString((int) dataBytes[1]));

                // Got profiler velocity data record
                // Read size of record (in WORDS)
                if ((nRead = input.read(dataBytes, 2, 2)) != 2) {
                    throw new Exception("error while reading record size - got " + nRead + " bytes");
                }

                log.debug("read(): totalWords=" + DataStructure.totalWords(dataBytes)  + " words");

                // Compute number of record bytes that remain to be read.
                // (Note that we've already read 4 of the bytes...)
                int remainingBytes = DataStructure.totalWords(dataBytes) * 2 - 4;

                nRead = StreamUtils.readBytes(input, dataBytes, 4,
                        remainingBytes, 10000);

                log.debug("read(): read " + nRead + " bytes");
                log.debug("read(): last byte: 0x" + Integer.toHexString((int) dataBytes[nRead-1+4]));

                if (nRead != remainingBytes) {
                    log.error("read(): recordBytes= " +
                            remainingBytes + ", nRead=" + nRead);
                }

                break;
            }
        }
        int nBytes = 4 + nRead;
        return nBytes;
    }


    // Convert two contiguous bytes to a short; assumes little-endian
    static short getShort(byte lsb, byte msb) {
        return (short) ((lsb & 0xFF) | ((msb & 0xFF) << 8));
    }

    /** Return two bytes of the input short, in little-endian order. */
    static byte[] getShortBytes(short value) {
        byte[] bytes = new byte[2];

        // Lease-significant byte comes first
        bytes[0] = (byte )(value & 0xFF);

        // Most significant byte comes second
        bytes[1] = (byte )(value >> 8);

        return bytes;
    }


    /** Convert two contiguous bytes to a short, starting at specified
     index of dataBytes; assumes little-endian. */
    short getShort(int index) {
        short lsb = (short )(_dataBytes[index] & 0xFF);
        short msb = (short )(_dataBytes[index+1] & 0xFF);
        return (short) (lsb | (msb << 8));
    }

    /** Convert byte to short	*/
    short getByte(int index)
    {
	return((short)(_dataBytes[index] & 0xFF));
    }


    // Convert four contiguous bytes to an integer; assumes little-endian
    static int getInteger(byte[] intBytes) {
        int value = 0;
        int shift = 0;
        for (int i = 0; i < 4; i++) {
            value |= (intBytes[i] & 0xff) << shift;
            shift += 8;
        }
        return value;
    }

}
