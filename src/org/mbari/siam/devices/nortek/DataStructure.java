package org.mbari.siam.devices.nortek;

/** * Copyright 2012 MBARI */

import org.mbari.siam.utils.StopWatch;
import org.mbari.siam.utils.StreamUtils;
import org.apache.log4j.Logger;
import org.mbari.siam.distributed.TimeoutException;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;



/** Data structure represents data generated by the Aquadopp, and includes
 method to read the data. */
public class DataStructure implements Serializable {

    private static final Logger log = Logger.getLogger(DataStructure.class);
    private static final long serialVersionUID=1L;
    private static short CHECKSUM_BASE=(short)0xb58c;
    public static final byte ID_HW_CONFIG=0x05;
    public static final byte ID_HEAD_CONFIG=0x04;
    public static final byte ID_USER_CONFIG=0x00;
    public static final byte ID_ADOP_VELOCITY=0x01;
    public static final byte ID_ADOP_DIAG_HEAD=0x06;
    public static final byte ID_ADOP_DIAG_DATA=(byte)0x80;
    public static final byte ID_ADOP_PROF_VELOCITY=0x21;
    public static final byte ID_ADOP_PROF_PROFILE=0x2a;
    public static final byte ID_VECTOR_VELOCITY_DATA=0x10;
    public static final byte ID_VECTOR_SYSTEM_DATA=0x11;
    public static final byte ID_VECTOR_VELOCITY_DATA_HEADER=0x12;

    protected static final long INTERCHAR_TIMEOUT=100;
    protected static final long PACKET_TIMEOUT=1000;
	
    // "Raw" bytes of structure
    byte[] _dataBytes = new byte[2048];

    public DataStructure() {
    }

    public static boolean isInstrumentConfiguration(byte[] dataBytes) {
        return id(dataBytes) == Aquadopp.INSTRUMENT_CONFIGURATION;
    }

    public static boolean isHRProfilerData(byte[] dataBytes) {
        return id(dataBytes) == Aquadopp.HR_PROFILER_DATA;
    }

    public static boolean isProfilerVelocityData(byte[] dataBytes) {
        return id(dataBytes) == Aquadopp.PROFILER_VELOCITY_DATA;
    }

    public static boolean isVectorVelocityData(byte[] dataBytes) {
        return id(dataBytes) == ID_VECTOR_VELOCITY_DATA;
    }

    /** Return id of this structure. */
    public byte id() {
        return _dataBytes[1];
    }

    /** Return id of this structure. */
    public static byte id(byte[] dataBytes) {
        return dataBytes[1];
    }

    /** Return total words in this structure. */
    public short totalWords() {
	/* Vector Velocity message is special case - no word counter */
	if (id() == ID_VECTOR_VELOCITY_DATA)
	    return(12);

        short hibyte = (short )_dataBytes[3];
        return (short) ((_dataBytes[2] & 0xff) | (hibyte << 8));
    }


    /** Return total words in this structure. */
    public static short totalWords(byte[] dataBytes) {

	/* Vector Velocity message is special case - no word counter */
	if (id(dataBytes) == ID_VECTOR_VELOCITY_DATA)
	    return(12);

        short hibyte = (short)dataBytes[3];
        return (short) ((dataBytes[2] & 0xff) | (hibyte << 8));
    }


    /** Set contents of raw data byte array. */
    public void setBytes(byte[] dataBytes) {
        if (_dataBytes.length < dataBytes.length) {
            _dataBytes = new byte[dataBytes.length];
        }

        System.arraycopy(dataBytes, 0, _dataBytes, 0, dataBytes.length);
    }

    /** String representation */
    public String toString() {
        return "id=0x" + Integer.toHexString(id())  + "; totalWords=" + totalWords();
    }


    /** Read raw bytes of a single data structure from the input stream. */
    public static int read(InputStream input, byte[] dataBytes, long timeoutMsec) throws TimeoutException, IOException, Exception {
		
		
		byte[] syncTerm=new byte[1];
		syncTerm[0]=(byte)Aquadopp.SYNC_BYTE;
		int bytesRead=0;
		
		// mark start time
		long startTime=System.currentTimeMillis();
		long elapsedTime=0;
		short compChksum=-1;
		short readChksum=-1;
		while ((elapsedTime=(System.currentTimeMillis()-startTime))<timeoutMsec) {

			if(log.isDebugEnabled()){
			    log.debug("find sync...t"+elapsedTime);
			}
			
			// look for sync byte
			// may throw TimeoutException
			StreamUtils.skipUntil(input,syncTerm,timeoutMsec-elapsedTime,1600);
			
			// set sync byte in data buffer
			dataBytes[0]=(byte)Aquadopp.SYNC_BYTE;
			
			if(log.isDebugEnabled()){
				log.debug("got sync...t"+(System.currentTimeMillis()-startTime));
			}
			
			// wait for ID byte
			// share processor if not ready
			while(input.available()<=0){
				StopWatch.delay(20);
				if((System.currentTimeMillis()-startTime)>INTERCHAR_TIMEOUT){
					throw new TimeoutException("Timeout waiting for ID byte");
				}
			}
			
			if(log.isDebugEnabled()){
				log.debug("get ID...t"+(System.currentTimeMillis()-startTime));
			}
			
			// read ID byte
			int idByte=input.read();
			if(idByte<0){
				throw new Exception("read() - eof while reading record type");
			}
			dataBytes[1]=(byte)(idByte & 0x000000ff);
			
			if(log.isDebugEnabled()){
				log.debug("read: Record is type 0x" + Integer.toHexString((int) dataBytes[1]));
				log.debug("get record size...t"+(System.currentTimeMillis()-startTime));
			}
			
			// validate record type
			// and set max record size
			int maxRecordSize=1;
			boolean idValid=false;
			if(dataBytes[1]==DataStructure.ID_ADOP_PROF_PROFILE){
				maxRecordSize=1600;
				idValid=true;
			}else if(dataBytes[1]==DataStructure.ID_ADOP_PROF_VELOCITY){
				maxRecordSize=1600;
				idValid=true;
			}else if(dataBytes[1]==DataStructure.ID_HW_CONFIG){
				maxRecordSize=48;
				idValid=true;
			}else if(dataBytes[1]==DataStructure.ID_HEAD_CONFIG){
				maxRecordSize=224;
				idValid=true;
			}else if(dataBytes[1]==DataStructure.ID_USER_CONFIG){
			   maxRecordSize=512;
			   idValid=true;
		   }else if(dataBytes[1]==DataStructure.ID_ADOP_VELOCITY){
			   maxRecordSize=42;
			   idValid=true;
		   }else if(dataBytes[1]==DataStructure.ID_ADOP_DIAG_HEAD){
			   maxRecordSize=36;
			   idValid=true;
		   }else if(dataBytes[1]==DataStructure.ID_ADOP_DIAG_DATA){
			   maxRecordSize=36;
			   idValid=true;
		   } 
			
			// check for valid type
			// ignore invalid types
			if(idValid==true){
				
				// wait for record size word
				// share processor if not ready
				while(input.available()<2){
					StopWatch.delay(20);
					if((System.currentTimeMillis()-startTime)>INTERCHAR_TIMEOUT){
						throw new TimeoutException("Timeout waiting for record size word");
					}
				}
				
				// read record size word
				bytesRead=input.read(dataBytes,2,2);
				if(bytesRead!=2){
					throw new Exception("error reading record size word: [" + bytesRead + " bytes]");
				}
				
				// compute total record size
				// returns an short int (record size, in words)
				// which we promote to int and mask 
				// to create an unsigned value
				int recordWords=((int)DataStructure.totalWords(dataBytes)) & 0x0000ffff;
				int recordBytes=2*recordWords;
				
				if(log.isDebugEnabled()){
					log.debug("read(): recordBytes=" + recordBytes);
				}
				
				if(recordBytes>4 && recordBytes<=maxRecordSize){
					// record size plausible...
					// Compute number of record bytes that remain to be read.
					// (Note that we've already read 4 of the bytes...)
					int remainingBytes = recordBytes - 4;
					
					// readBytes will happily fill your buffer and return, even if the buffer is too small
					// make sure the buffer is large enough
					if(dataBytes.length < recordBytes){
						log.error("data buffer < record size: ["+dataBytes.length+"<"+recordBytes+"]");
					}
					
					// compute time remaining
					elapsedTime=(System.currentTimeMillis()-startTime);
					long timeRemaining=(timeoutMsec-elapsedTime);
					if(log.isDebugEnabled()){
						log.debug("get record data t" + elapsedTime);
					}
					
					// if there's time, read the data bytes
//					if(timeRemaining>0){
//						bytesRead = StreamUtils.readBytes(input, dataBytes, 4,remainingBytes, timeRemaining);
//					}else{
//						throw new TimeoutException("Timeout before data read");		
//					}

					//We got this far, leave enough time to see if we got a good packet, rah 12/16/2009
					if (timeRemaining < PACKET_TIMEOUT)
					    timeRemaining = PACKET_TIMEOUT;

					bytesRead = StreamUtils.readBytes(input, dataBytes, 4,remainingBytes, timeRemaining);
					
					if(log.isDebugEnabled()){
						log.debug("read: read " + bytesRead + " bytes");
					}

					if (bytesRead == remainingBytes){
						// find index of last byte
						int idx=4+bytesRead-1;
						if( idx >= (dataBytes.length-1)){
							idx=dataBytes.length-1;
						}
						
						if(log.isDebugEnabled()){
							log.debug("read: last idx " + idx + " [0x"+Integer.toHexString(dataBytes[idx-1])+",0x"+Integer.toHexString(dataBytes[idx])+"]");
						}
						
						// read checksum
						short hiByte=(short)(dataBytes[idx]);
						readChksum= (short)((short)(dataBytes[idx-1] & 0x00ff) | (hiByte<<8));
						
						// compute checksum
						compChksum=CHECKSUM_BASE;
						for(int i=0;i<recordWords-1;i++){
							short scHi=((short)dataBytes[2*i+1]);
							short scLo=((short)dataBytes[2*i]);
							short scWord=(short)((scLo & 0x00ff) | (scHi<<8));
							compChksum+=scWord;
							//log.debug("i "+i+" lo "+Integer.toHexString(scLo)+" hi "+Integer.toHexString(scHi)+" word "+Integer.toHexString(scWord)+" sum "+Integer.toHexString(compChksum));
						}
						
						// compare reported and computed checksum
						if(readChksum==compChksum){
							// read successful
							if(log.isDebugEnabled()){
								log.debug("read:OK returning " + (bytesRead+4)+" t"+(System.currentTimeMillis()-startTime));
							}

							return (bytesRead+4);
						}else{
							// if bytes are missing
							// flag an error
						    log.error("Checksum failed read 0x" + Integer.toHexString(readChksum)+" comp 0x"+Integer.toHexString(compChksum) + " t"+(System.currentTimeMillis()-startTime));
						}
					}else{
						// if bytes are missing
						// flag an error
						log.error("read: expected= "+remainingBytes+ " read=" + bytesRead);
					}
				}else{
					//throw new Exception("record size<0: ["+recordBytes+"]");
					if(log.isDebugEnabled()){
						log.debug("invalid record size: ["+recordBytes+"]");
					}
					// probably reading from middle of record
					// reset and start over
					//startTime=System.currentTimeMillis();					
				}
			}else{
				// invalid recordType
				if(log.isDebugEnabled()){
					log.debug("invalid record Id: ["+dataBytes[1]+"]");
				}
			}
		}//end while

		throw new TimeoutException("read: timeout");
    }
	

    // Convert two contiguous bytes to a short; assumes little-endian
    static short getShort(byte lsb, byte msb) {
        return (short) ((lsb & 0xFF) | ((msb & 0xFF) << 8));
    }

    /** Return two bytes of the input short, in little-endian order. */
    static byte[] getShortBytes(short value) {
        byte[] bytes = new byte[2];

        // Lease-significant byte comes first
        bytes[0] = (byte )(value & 0xFF);

        // Most significant byte comes second
        bytes[1] = (byte )(value >> 8);

        return bytes;
    }


    /** Convert two contiguous bytes to a short, starting at specified
     index of dataBytes; assumes little-endian. */
    short getShort(int index) {
        short lsb = (short )(_dataBytes[index] & 0xFF);
        short msb = (short )(_dataBytes[index+1] & 0xFF);
        return (short) (lsb | (msb << 8));
    }

    /** Convert byte to short	*/
    short getByte(int index)
    {
	return((short)(_dataBytes[index] & 0xFF));
    }


    // Convert four contiguous bytes to an integer; assumes little-endian
    static int getInteger(byte[] intBytes) {
        int value = 0;
        int shift = 0;
        for (int i = 0; i < 4; i++) {
            value |= (intBytes[i] & 0xff) << shift;
            shift += 8;
        }
        return value;
    }

}
